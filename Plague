local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/Explosive-Soda/HAPPY-SCRIPT/refs/heads/main/Rayfield%20modified'))()

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local TeleportService = game:GetService("TeleportService")
local players = game:GetService("Players")
local wrk = game:GetService("Workspace")
local plr = players.LocalPlayer
local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
local humanoid = plr.Character:FindFirstChild("Humanoid")

local function onCharacterAdded(character)
    hrp = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
end

plr.CharacterAdded:Connect(onCharacterAdded)

if plr.Character then
    onCharacterAdded(plr.Character)
end

local camera = wrk.CurrentCamera
local mouse = plr:GetMouse()

local httprequest = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request

local hue = 0
local rainbowFov = false
local rainbowSpeed = 0.005

local aimFov = 150
local aimParts = {"Head"}
local aiming = false
local predictionStrength = 0.03
local smoothing = 0.97

local aimbotEnabled = false
local wallCheck = true
local stickyAimEnabled = false
local teamCheck = false
local healthCheck = false
local minHealth = 1

local antiAim = false

local antiAimAmountX = 0
local antiAimAmountY = -100
local antiAimAmountZ = 0

local antiAimMethod = "Reset Velo"

local randomVeloRange = 100

local spinBot = false
local spinBotSpeed = 20

local circleColor = Color3.fromRGB(255, 255, 255)
local targetedCircleColor = Color3.fromRGB(255, 0, 0)

local aimViewerEnabled = false
local ignoreSelf = true

local Window = Rayfield:CreateWindow({
    Name = "Universal aimbot",
    LoadingTitle = "Loading...",
    LoadingSubtitle = "Soda made this",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "Universal aimbot",
        FileName = "Version"
    },
})

local Aimbot = Window:CreateTab("Aimbot")
local ESP = Window:CreateTab("ESP")
local AntiAim = Window:CreateTab("Anti-Aim")
local Misc = Window:CreateTab("Misc")

local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 2
fovCircle.Radius = aimFov
fovCircle.Filled = false
fovCircle.Color = circleColor
fovCircle.Visible = false

local currentTarget = nil

-- ‰øÆÊîπÔºöÊ†πÊçÆCharacterType attributeÊ£ÄÊü•Âõ¢Èòü
local function checkTeam(player)
    if not teamCheck then return false end
    
    local myCharacter = plr.Character
    local targetCharacter = player.Character
    
    if not myCharacter or not targetCharacter then return false end
    
    -- Ëé∑ÂèñÂèåÊñπÁöÑCharacterType attribute
    local myCharType = myCharacter:GetAttribute("CharacterType")
    local targetCharType = targetCharacter:GetAttribute("CharacterType")
    
    -- Â¶ÇÊûúÊ∏∏Êàè‰∫∫Áâ©ÂêçÂ≠óÊòØLunarVersionÔºå‰ΩøÁî®ÁâπÊÆäÈÄªËæë
    if plr.Name == "LunarVersion" then
        if myCharType == "Survivor" then
            return targetCharType == "Survivor" -- Â¶ÇÊûúÊòØÂπ∏Â≠òËÄÖÔºåÂàôÂπ∏Â≠òËÄÖÊòØÈòüÂèã
        elseif myCharType == "Zombie" then
            return targetCharType == "Zombie" -- Â¶ÇÊûúÊòØÂÉµÂ∞∏ÔºåÂàôÂÉµÂ∞∏ÊòØÈòüÂèã
        end
    else
        -- ÂÖ∂‰ªñÁé©ÂÆ∂‰ΩøÁî®ÈªòËÆ§ÈÄªËæë
        if myCharType and targetCharType then
            return myCharType == targetCharType
        end
    end
    
    return false
end

-- ‰øÆÊîπÔºöËé∑ÂèñÊïåÂØπÁ±ªÂûã
local function getEnemyType()
    local myCharacter = plr.Character
    if not myCharacter then return nil end
    
    local myCharType = myCharacter:GetAttribute("CharacterType")
    if not myCharType then return nil end
    
    if plr.Name == "LunarVersion" then
        if myCharType == "Survivor" then
            return "Zombie"
        elseif myCharType == "Zombie" then
            return "Survivor"
        end
    else
        if myCharType == "Survivor" then
            return "Zombie"
        elseif myCharType == "Zombie" then
            return "Survivor"
        end
    end
    
    return nil
end

-- ‰øÆÊîπÔºöÊ£ÄÊü•ÊòØÂê¶‰∏∫Êïå‰∫∫
local function isEnemy(player)
    if not teamCheck then return true end
    
    local targetCharacter = player.Character
    if not targetCharacter then return false end
    
    local targetCharType = targetCharacter:GetAttribute("CharacterType")
    local enemyType = getEnemyType()
    
    if targetCharType and enemyType then
        return targetCharType == enemyType
    end
    
    return true
end

local function checkWall(targetCharacter)
    local targetHead = targetCharacter:FindFirstChild("Head")
    if not targetHead then return true end

    local origin = camera.CFrame.Position
    local direction = (targetHead.Position - origin).unit * (targetHead.Position - origin).magnitude
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {plr.Character, targetCharacter}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = wrk:Raycast(origin, direction, raycastParams)
    return raycastResult and raycastResult.Instance ~= nil
end

local function getClosestPart(character)
    local closestPart = nil
    local shortestCursorDistance = aimFov
    local cameraPos = camera.CFrame.Position

    for _, partName in ipairs(aimParts) do
        local part = character:FindFirstChild(partName)
        if part then
            local partPos = camera:WorldToViewportPoint(part.Position)
            local screenPos = Vector2.new(partPos.X, partPos.Y)
            local cursorDistance = (screenPos - Vector2.new(mouse.X, mouse.Y)).Magnitude

            if cursorDistance < shortestCursorDistance and partPos.Z > 0 then
                shortestCursorDistance = cursorDistance
                closestPart = part
            end
        end
    end

    return closestPart
end

local function getTarget()
    local nearestPlayer = nil
    local closestPart = nil
    local shortestCursorDistance = aimFov

    for _, player in ipairs(players:GetPlayers()) do
        if player ~= plr and player.Character and player.Character:FindFirstChild("Humanoid") then
            -- ‰øÆÊîπÔºö‰ΩøÁî®Êñ∞ÁöÑÂõ¢ÈòüÊ£ÄÊü•ÈÄªËæë
            local isEnemyPlayer = isEnemy(player)
            
            if isEnemyPlayer then
                if player.Character.Humanoid.Health >= minHealth or not healthCheck then
                    local targetPart = getClosestPart(player.Character)
                    if targetPart then
                        local screenPos = camera:WorldToViewportPoint(targetPart.Position)
                        local cursorDistance = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(mouse.X, mouse.Y)).Magnitude

                        if cursorDistance < shortestCursorDistance then
                            if not wallCheck or not checkWall(player.Character) then
                                shortestCursorDistance = cursorDistance
                                nearestPlayer = player
                                closestPart = targetPart
                            end
                        end
                    end
                end
            end
        end
    end

    return nearestPlayer, closestPart
end

local function predict(player, part)
    if player and part then
        local velocity = player.Character.HumanoidRootPart.Velocity
        local predictedPosition = part.Position + (velocity * predictionStrength)
        return predictedPosition
    end
    return nil
end

local function smooth(from, to)
    return from:Lerp(to, smoothing)
end

local function aimAt(player, part)
    local predictedPosition = predict(player, part)
    if predictedPosition then
        if player.Character.Humanoid.Health >= minHealth or not healthCheck then
            local targetCFrame = CFrame.new(camera.CFrame.Position, predictedPosition)
            camera.CFrame = smooth(camera.CFrame, targetCFrame)
        end
    end
end

RunService.RenderStepped:Connect(function()
    if aimbotEnabled then
        local offset = 50
        fovCircle.Position = Vector2.new(mouse.X, mouse.Y + offset)

        if rainbowFov then
            hue = hue + rainbowSpeed
            if hue > 1 then hue = 0 end
            fovCircle.Color = Color3.fromHSV(hue, 1, 1)
        else
            if aiming and currentTarget then
                fovCircle.Color = targetedCircleColor
            else
                fovCircle.Color = circleColor
            end
        end

        if aiming then
            if stickyAimEnabled and currentTarget then
                local headPos = camera:WorldToViewportPoint(currentTarget.Character.Head.Position)
                local screenPos = Vector2.new(headPos.X, headPos.Y)
                local cursorDistance = (screenPos - Vector2.new(mouse.X, mouse.Y)).Magnitude

                if cursorDistance > aimFov or (wallCheck and checkWall(currentTarget.Character)) or not isEnemy(currentTarget) then
                    currentTarget = nil
                end
            end

            if not stickyAimEnabled or not currentTarget then
                local target, targetPart = getTarget()
                currentTarget = target
                currentTargetPart = targetPart
            end

            if currentTarget and currentTargetPart then
                aimAt(currentTarget, currentTargetPart)
            end
        else
            currentTarget = nil
        end
    end
end)

RunService.Heartbeat:Connect(function()
    if antiAim then
        if antiAimMethod == "Reset Velo" then
            local vel = hrp.Velocity
            hrp.Velocity = Vector3.new(antiAimAmountX, antiAimAmountY, antiAimAmountZ)
            RunService.RenderStepped:Wait()
            hrp.Velocity = vel
        elseif antiAimMethod == "Reset Pos [BROKEN]" then
            local pos = hrp.CFrame
            hrp.Velocity = Vector3.new(antiAimAmountX, antiAimAmountY, antiAimAmountZ)
            RunService.RenderStepped:Wait()
            hrp.CFrame = pos
        elseif antiAimMethod == "Random Velo" then
            local vel = hrp.Velocity
            local a = math.random(-randomVeloRange,randomVeloRange)
            local s = math.random(-randomVeloRange,randomVeloRange)
            local d = math.random(-randomVeloRange,randomVeloRange)
            hrp.Velocity = Vector3.new(a,s,d)
            RunService.RenderStepped:Wait()
            hrp.Velocity = vel
        end
    end
end)

mouse.Button2Down:Connect(function()
    if aimbotEnabled then
        aiming = true
    end
end)

mouse.Button2Up:Connect(function()
    if aimbotEnabled then
        aiming = false
    end
end)

local aimbot = Aimbot:CreateToggle({
    Name = "Aimbot",
    CurrentValue = false,
    Flag = "Aimbot",
    Callback = function(Value)
        aimbotEnabled = Value
        fovCircle.Visible = false
    end
})

local aimpart = Aimbot:CreateDropdown({
    Name = "Aim Part",
    Options = {"Head","HumanoidRootPart","Left Arm","Right Arm","Torso","Left Leg","Right Leg"},
    CurrentOption = {"Head"},
    MultipleOptions = true,
    Flag = "AimPart",
    Callback = function(Options)
        aimParts = Options
    end,
 })

local smoothingslider = Aimbot:CreateSlider({
    Name = "Smoothing",
    Range = {0, 100},
    Increment = 1,
    CurrentValue = 3,
    Flag = "Smoothing",
    Callback = function(Value)
        smoothing = 1 - (math.round(Value) / 100)
    end,
})

local predictionstrength = Aimbot:CreateSlider({
    Name = "Prediction Strength",
    Range = {0, 0.2},
    Increment = 0.001,
    CurrentValue = 0.03,
    Flag = "PredictionStrength",
    Callback = function(Value)
        predictionStrength = Value
    end,
})

local fovvisibility = Aimbot:CreateToggle({
    Name = "Fov Visibility",
    CurrentValue = false,
    Flag = "FovVisibility",
    Callback = function(Value)
        fovCircle.Visible = Value and aimbotEnabled
    end
})

local aimbotfov = Aimbot:CreateSlider({
    Name = "Aimbot Fov",
    Range = {0, 1000},
    Increment = 1,
    CurrentValue = 150,
    Flag = "AimbotFov",
    Callback = function(Value)
        aimFov = Value
        fovCircle.Radius = aimFov
    end,
})

local wallcheck = Aimbot:CreateToggle({
    Name = "Wall Check",
    CurrentValue = true,
    Flag = "WallCheck",
    Callback = function(Value)
        wallCheck = Value
    end
})

local stickyaim = Aimbot:CreateToggle({
    Name = "Sticky Aim",
    CurrentValue = false,
    Flag = "StickyAim",
    Callback = function(Value)
        stickyAimEnabled = Value
    end
})

local teamchecktoggle = Aimbot:CreateToggle({
    Name = "Team Check",
    CurrentValue = false,
    Flag = "TeamCheck",
    Callback = function(Value)
        teamCheck = Value
    end
})

local healthchecktoggle = Aimbot:CreateToggle({
    Name = "Health Check",
    CurrentValue = false,
    Flag = "HealthCheck",
    Callback = function(Value)
        healthCheck = Value
    end
})

local minhealth = Aimbot:CreateSlider({
    Name = "Min Health",
    Range = {0, 100},
    Increment = 1,
    CurrentValue = 1,
    Flag = "MinHealth",
    Callback = function(Value)
        minHealth = Value
    end,
})

local circlecolor = Aimbot:CreateColorPicker({
    Name = "Fov Color",
    Color = circleColor,
    Callback = function(Color)
        circleColor = Color
        fovCircle.Color = Color
    end
})

local targetedcirclecolor = Aimbot:CreateColorPicker({
    Name = "Targeted Fov Color",
    Color = targetedCircleColor,
    Callback = function(Color)
        targetedCircleColor = Color
    end
})

local circlerainbow = Aimbot:CreateToggle({
    Name = "Rainbow Fov",
    CurrentValue = false,
    Flag = "RainbowFov",
    Callback = function(Value)
        rainbowFov = Value
    end
})

-- ESPÂäüËÉΩÂèòÈáè
local espEnabled = false
local espTeamCheck = false
local espColor = Color3.fromRGB(255, 255, 255)
local espHighlights = {}
local boxESPEnabled = false
local boxESPColor = Color3.fromRGB(255, 255, 255)
local boxESPThickness = 1
local boxESPDrawings = {}

-- ‰øÆÊîπÔºöESPÊõ¥Êñ∞ÂáΩÊï∞Ôºå‰ΩøÁî®CharacterType attribute
local function updateESP()
    for _, player in ipairs(players:GetPlayers()) do
        if player ~= plr and player.Character and player.Character:FindFirstChild("Humanoid") then
            local char = player.Character
            local alive = char.Humanoid.Health > 0
            local isEnemyPlayer = not espTeamCheck or isEnemy(player)

            if alive and isEnemyPlayer then
                -- HighlightÁªÑ‰ª∂ÈÄªËæë
                if not espHighlights[player] then
                    local hl = Instance.new("Highlight")
                    hl.Parent = char
                    hl.FillColor = espColor
                    hl.OutlineTransparency = 0.5
                    hl.OutlineColor = Color3.new(0, 0, 0)
                    hl.Adornee = char
                    hl.Enabled = espEnabled
                    espHighlights[player] = hl
                else
                    local hl = espHighlights[player]
                    hl.FillColor = espColor
                    hl.OutlineTransparency = 0.5
                    hl.OutlineColor = Color3.new(0, 0, 0)
                    hl.Enabled = espEnabled
                    if hl.Parent ~= char then
                        hl.Parent = char
                        hl.Adornee = char
                    end
                end

                -- Box ESPÈÄªËæë
                if boxESPEnabled then
                    local humanoidRootPart = char:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        if not boxESPDrawings[player] then
                            -- ÂàõÂª∫Box ESPÁªòÂõæ
                            local box = {
                                Top = Drawing.new("Line"),
                                Bottom = Drawing.new("Line"),
                                Left = Drawing.new("Line"),
                                Right = Drawing.new("Line")
                            }
                            
                            -- ËÆæÁΩÆÊâÄÊúâÁ∫øÁöÑÂ±ûÊÄß
                            for _, line in pairs(box) do
                                line.Thickness = boxESPThickness
                                line.Color = boxESPColor
                                line.Visible = true
                            end
                            
                            boxESPDrawings[player] = box
                        end
                        
                        -- Êõ¥Êñ∞Box‰ΩçÁΩÆ
                        local box = boxESPDrawings[player]
                        local head = char:FindFirstChild("Head")
                        local torso = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
                        
                        if head and torso then
                            local headPos, headVisible = camera:WorldToViewportPoint(head.Position)
                            local torsoPos, torsoVisible = camera:WorldToViewportPoint(torso.Position)
                            
                            if headVisible and torsoVisible then
                                local height = math.abs(headPos.Y - torsoPos.Y) * 2.5
                                local width = height * 0.6
                                
                                local topY = headPos.Y - height * 0.3
                                local bottomY = torsoPos.Y + height * 0.2
                                local leftX = torsoPos.X - width / 2
                                local rightX = torsoPos.X + width / 2
                                
                                -- Êõ¥Êñ∞BoxÁ∫øÊù°‰ΩçÁΩÆ
                                box.Top.From = Vector2.new(leftX, topY)
                                box.Top.To = Vector2.new(rightX, topY)
                                
                                box.Bottom.From = Vector2.new(leftX, bottomY)
                                box.Bottom.To = Vector2.new(rightX, bottomY)
                                
                                box.Left.From = Vector2.new(leftX, topY)
                                box.Left.To = Vector2.new(leftX, bottomY)
                                
                                box.Right.From = Vector2.new(rightX, topY)
                                box.Right.To = Vector2.new(rightX, bottomY)
                                
                                -- ËÆæÁΩÆÊâÄÊúâÁ∫øÂèØËßÅ
                                for _, line in pairs(box) do
                                    line.Visible = true
                                end
                            else
                                -- Â¶ÇÊûúËßíËâ≤‰∏çÂú®ËßÜÈáéÂÜÖÔºåÈöêËóèBox
                                for _, line in pairs(box) do
                                    line.Visible = false
                                end
                            end
                        end
                    end
                else
                    -- Â¶ÇÊûúBox ESPÁ¶ÅÁî®ÔºåÈöêËóèËØ•Áé©ÂÆ∂ÁöÑBox
                    if boxESPDrawings[player] then
                        for _, line in pairs(boxESPDrawings[player]) do
                            line.Visible = false
                        end
                    end
                end
            else
                -- Â¶ÇÊûúËßíËâ≤Ê≠ª‰∫°Êàñ‰∏çÁ¨¶ÂêàÊù°‰ª∂ÔºåÂÖ≥Èó≠ Highlight Âíå Box
                if espHighlights[player] then
                    espHighlights[player].Enabled = false
                end
                if boxESPDrawings[player] then
                    for _, line in pairs(boxESPDrawings[player]) do
                        line.Visible = false
                    end
                end
            end
        else
            -- Áé©ÂÆ∂‰∏çÂ≠òÂú®ÊàñÊ≤°ÊúâËßíËâ≤ÔºåÊ∏ÖÁêÜHighlightÂíåBox
            if espHighlights[player] then
                espHighlights[player]:Destroy()
                espHighlights[player] = nil
            end
            if boxESPDrawings[player] then
                for _, line in pairs(boxESPDrawings[player]) do
                    line:Remove()
                end
                boxESPDrawings[player] = nil
            end
        end
    end
end

-- Áé©ÂÆ∂ËøûÊé•/Êñ≠ÂºÄÂ§ÑÁêÜ
local function onPlayerAdded(player)
    player.CharacterAdded:Connect(function(character)
        if espEnabled or boxESPEnabled then
            updateESP()
        end
    end)
    
    player.CharacterRemoving:Connect(function()
        if espHighlights[player] then
            espHighlights[player]:Destroy()
            espHighlights[player] = nil
        end
        if boxESPDrawings[player] then
            for _, line in pairs(boxESPDrawings[player]) do
                line:Remove()
            end
            boxESPDrawings[player] = nil
        end
    end)
end

local function onPlayerRemoving(player)
    if espHighlights[player] then
        espHighlights[player]:Destroy()
        espHighlights[player] = nil
    end
    if boxESPDrawings[player] then
        for _, line in pairs(boxESPDrawings[player]) do
            line:Remove()
        end
        boxESPDrawings[player] = nil
    end
end

-- ÂàùÂßãÂåñÁé∞ÊúâÁé©ÂÆ∂
for _, player in ipairs(players:GetPlayers()) do
    onPlayerAdded(player)
end

players.PlayerAdded:Connect(onPlayerAdded)
players.PlayerRemoving:Connect(onPlayerRemoving)

-- ESPÊ∏≤ÊüìÂæ™ÁéØ
RunService.RenderStepped:Connect(function()
    if espEnabled or boxESPEnabled then
        updateESP()
    else
        -- ÂÖ≥Èó≠ÊâÄÊúâHighlightÂíåBox
        for _, hl in pairs(espHighlights) do
            hl.Enabled = false
        end
        for _, box in pairs(boxESPDrawings) do
            for _, line in pairs(box) do
                line.Visible = false
            end
        end
    end
end)

-- ESP UIÊéß‰ª∂
local espToggle = ESP:CreateToggle({
    Name = "ESP",
    CurrentValue = false,
    Flag = "ESP",
    Callback = function(Value)
        espEnabled = Value
        if not Value then
            -- ÂÖ≥Èó≠ÊâÄÊúâHighlight
            for _, hl in pairs(espHighlights) do
                hl.Enabled = false
            end
        else
            updateESP()
        end
    end
})

local boxESPToggle = ESP:CreateToggle({
    Name = "Box ESP",
    CurrentValue = false,
    Flag = "BoxESP",
    Callback = function(Value)
        boxESPEnabled = Value
        if not Value then
            -- ÂÖ≥Èó≠ÊâÄÊúâBox ESP
            for _, box in pairs(boxESPDrawings) do
                for _, line in pairs(box) do
                    line.Visible = false
                end
            end
        else
            updateESP()
        end
    end
})

local espTeamCheckToggle = ESP:CreateToggle({
    Name = "Team Check",
    CurrentValue = false,
    Flag = "ESPTeamCheck",
    Callback = function(Value)
        espTeamCheck = Value
        if espEnabled or boxESPEnabled then
            updateESP()
        end
    end
})

local espColorPicker = ESP:CreateColorPicker({
    Name = "ESP Color",
    Color = espColor,
    Callback = function(Color)
        espColor = Color
        if espEnabled then
            updateESP()
        end
    end
})

local boxESPColorPicker = ESP:CreateColorPicker({
    Name = "Box ESP Color",
    Color = boxESPColor,
    Callback = function(Color)
        boxESPColor = Color
        if boxESPEnabled then
            for _, box in pairs(boxESPDrawings) do
                for _, line in pairs(box) do
                    line.Color = Color
                end
            end
        end
    end
})

local boxESPThicknessSlider = ESP:CreateSlider({
    Name = "Box ESP Thickness",
    Range = {1, 5},
    Increment = 1,
    CurrentValue = 1,
    Flag = "BoxESPThickness",
    Callback = function(Value)
        boxESPThickness = Value
        if boxESPEnabled then
            for _, box in pairs(boxESPDrawings) do
                for _, line in pairs(box) do
                    line.Thickness = Value
                end
            end
        end
    end,
})

local antiaimtoggle = AntiAim:CreateToggle({
    Name = "Anti-Aim",
    CurrentValue = false,
    Flag = "AntiAim",
    Callback = function(Value)
        antiAim = Value
        if Value then
            Rayfield:Notify({Title = "Anti-Aim", Content = "Enabled!", Duration = 1, Image = 4483362458,})
        else
            Rayfield:Notify({Title = "Anti-Aim", Content = "Disabled!", Duration = 1, Image = 4483362458,})
        end
    end
})

local antiaimmethod = AntiAim:CreateDropdown({
    Name = "Anti-Aim Method",
    Options = {"Reset Velo","Random Velo","Reset Pos [BROKEN]"},
    CurrentOption = "Reset Velo",
    Flag = "AntiAimMethod",
    Callback = function(Option)
        antiAimMethod = type(Option) == "table" and Option[1] or Option
        if antiAimMethod == "Reset Velo" then
            Rayfield:Notify({Title = "Reset Velocity", Content = "Nobody will see it, but exploiters will aim in the wrong place.", Duration = 5, Image = 4483362458,})
        elseif antiAimMethod == "Reset Pos [BROKEN]" then
            Rayfield:Notify({Title = "Reset Pos [BROKEN]", Content = "This is a bit buggy right now, so idk if it works that well", Duration = 5, Image = 4483362458,})
        elseif antiAimMethod == "Random Velo" then
            Rayfield:Notify({Title = "Random Velocity", Content = "Depending on ping some peoplev will see u 'teleporting' around but you are actually in the same spot the entire time.", Duration = 5, Image = 4483362458,})
        end
    end,
})

local antiaimamountx = AntiAim:CreateSlider({
    Name = "Anti-Aim Amount X",
    Range = {-1000, 1000},
    Increment = 10,
    CurrentValue = 0,
    Flag = "AntiAimAmountX",
    Callback = function(Value)
        antiAimAmountX = Value
    end,
})

local antiaimamounty = AntiAim:CreateSlider({
    Name = "Anti-Aim Amount Y",
    Range = {-1000, 1000},
    Increment = 10,
    CurrentValue = -100,
    Flag = "AntiAimAmountY",
    Callback = function(Value)
        antiAimAmountY = Value
    end,
})

local antiaimamountz = AntiAim:CreateSlider({
    Name = "Anti-Aim Amount Z",
    Range = {-1000, 1000},
    Increment = 10,
    CurrentValue = 0,
    Flag = "AntiAimAmountZ",
    Callback = function(Value)
        antiAimAmountZ = Value
    end,
})

local randomvelorange = AntiAim:CreateSlider({
    Name = "Random Velo Range",
    Range = {0, 1000},
    Increment = 10,
    CurrentValue = 100,
    Flag = "RandomVeloRange",
    Callback = function(Value)
        randomVeloRange = Value
    end,
})

local spinbottoggle = Misc:CreateToggle({
    Name = "Spin-Bot",
    CurrentValue = false,
    Flag = "SpinBot",
    Callback = function(Value)
        spinBot = Value
        if Value then
            for i,v in pairs(hrp:GetChildren()) do
                if v.Name == "Spinning" then
                    v:Destroy()
                end
            end
            plr.Character.Humanoid.AutoRotate = false
            local Spin = Instance.new("BodyAngularVelocity")
            Spin.Name = "Spinning"
            Spin.Parent = hrp
            Spin.MaxTorque = Vector3.new(0, math.huge, 0)
            Spin.AngularVelocity = Vector3.new(0,spinBotSpeed,0)
            Rayfield:Notify({Title = "Spin Bot", Content = "Enabled!", Duration = 1, Image = 4483362458,})
        else
            for i,v in pairs(hrp:GetChildren()) do
                if v.Name == "Spinning" then
                    v:Destroy()
                end
            end
            plr.Character.Humanoid.AutoRotate = true
            Rayfield:Notify({Title = "Spin Bot", Content = "Disabled!", Duration = 1, Image = 4483362458,})
        end
    end
})

local spinbotspeed = Misc:CreateSlider({
    Name = "Spin-Bot Speed",
    Range = {0, 1000},
    Increment = 1,
    CurrentValue = 20,
    Flag = "SpinBotSpeed",
    Callback = function(Value)
        spinBotSpeed = Value
        if spinBot then
            for i,v in pairs(hrp:GetChildren()) do
                if v.Name == "Spinning" then
                    v:Destroy()
                end
            end
            local Spin = Instance.new("BodyAngularVelocity")
            Spin.Name = "Spinning"
            Spin.Parent = hrp
            Spin.MaxTorque = Vector3.new(0, math.huge, 0)
            Spin.AngularVelocity = Vector3.new(0,Value,0)
        end
    end,
})

local ConfigSection = Misc:CreateSection("Configuration Management")

local configFileName = "universal_hub_config.json"

local function saveConfiguration()
    local configData = {
        AimbotEnabled = aimbotEnabled,
        AimParts = aimParts,
        Smoothing = tonumber(string.format("%.6f", smoothing)),
        PredictionStrength = predictionStrength,
        AimFov = aimFov,
        WallCheck = wallCheck,
        StickyAim = stickyAimEnabled,
        TeamCheck = teamCheck,
        HealthCheck = healthCheck,
        MinHealth = minHealth,
        CircleColor = {R = circleColor.R, G = circleColor.G, B = circleColor.B},
        TargetedCircleColor = {R = targetedCircleColor.R, G = targetedCircleColor.G, B = targetedCircleColor.B},
        RainbowFov = rainbowFov,
        ESPEnabled = espEnabled,
        ESPTeamCheck = espTeamCheck,
        ESPColor = {R = espColor.R, G = espColor.G, B = espColor.B},
        BoxESPEnabled = boxESPEnabled,
        BoxESPColor = {R = boxESPColor.R, G = boxESPColor.G, B = boxESPColor.B},
        BoxESPThickness = boxESPThickness,
        AntiAim = antiAim,
        AntiAimMethod = antiAimMethod,
        AntiAimAmountX = antiAimAmountX,
        AntiAimAmountY = antiAimAmountY,
        AntiAimAmountZ = antiAimAmountZ,
        RandomVeloRange = randomVeloRange,
        SpinBot = spinBot,
        SpinBotSpeed = spinBotSpeed
    }
    
    local success, jsonData = pcall(function()
        return HttpService:JSONEncode(configData)
    end)
    
    if success then
        writefile(configFileName, jsonData)
        Rayfield:Notify({
            Title = "Configuration Saved", 
            Content = "All settings have been saved successfully!", 
            Duration = 1, 
            Image = 4483362458,
        })
        return true
    else
        Rayfield:Notify({
            Title = "Save Failed", 
            Content = "Failed to save configuration!", 
            Duration = 2, 
            Image = 4483362458,
        })
        return false
    end
end

local function loadConfiguration()
    if not isfile(configFileName) then
        Rayfield:Notify({
            Title = "Load Failed", 
            Content = "No saved configuration found!", 
            Duration = 2, 
            Image = 4483362458,
        })
        return false
    end
    
    local success, configData = pcall(function()
        return HttpService:JSONDecode(readfile(configFileName))
    end)
    
    if success and configData then
        if configData.AimbotEnabled ~= nil then
            aimbotEnabled = configData.AimbotEnabled
            fovCircle.Visible = aimbotEnabled
        end
        
        if configData.AimParts ~= nil then aimParts = configData.AimParts end
        if configData.Smoothing ~= nil then smoothing = configData.Smoothing end
        if configData.PredictionStrength ~= nil then predictionStrength = configData.PredictionStrength end
        if configData.AimFov ~= nil then
            aimFov = configData.AimFov
            fovCircle.Radius = aimFov
        end
        if configData.WallCheck ~= nil then wallCheck = configData.WallCheck end
        if configData.StickyAim ~= nil then stickyAimEnabled = configData.StickyAim end
        if configData.TeamCheck ~= nil then teamCheck = configData.TeamCheck end
        if configData.HealthCheck ~= nil then healthCheck = configData.HealthCheck end
        if configData.MinHealth ~= nil then minHealth = configData.MinHealth end
        
        if configData.CircleColor ~= nil then
            circleColor = Color3.new(configData.CircleColor.R, configData.CircleColor.G, configData.CircleColor.B)
            fovCircle.Color = circleColor
        end
        
        if configData.TargetedCircleColor ~= nil then
            targetedCircleColor = Color3.new(configData.TargetedCircleColor.R, configData.TargetedCircleColor.G, configData.TargetedCircleColor.B)
        end
        
        if configData.RainbowFov ~= nil then rainbowFov = configData.RainbowFov end
        if configData.ESPEnabled ~= nil then espEnabled = configData.ESPEnabled end
        if configData.ESPTeamCheck ~= nil then espTeamCheck = configData.ESPTeamCheck end
        if configData.ESPColor ~= nil then
          espColor = Color3.new(configData.ESPColor.R, configData.ESPColor.G, configData.ESPColor.B)
        end
        if configData.BoxESPEnabled ~= nil then boxESPEnabled = configData.BoxESPEnabled end
        if configData.BoxESPColor ~= nil then
          boxESPColor = Color3.new(configData.BoxESPColor.R, configData.BoxESPColor.G, configData.BoxESPColor.B)
        end
        if configData.BoxESPThickness ~= nil then boxESPThickness = configData.BoxESPThickness end
        if espToggle then espToggle:Set(espEnabled) end
        if espTeamCheckToggle then espTeamCheckToggle:Set(espTeamCheck) end
        if espColorPicker then espColorPicker:Set(espColor) end
        if boxESPToggle then boxESPToggle:Set(boxESPEnabled) end
        if boxESPColorPicker then boxESPColorPicker:Set(boxESPColor) end
        if boxESPThicknessSlider then boxESPThicknessSlider:Set(boxESPThickness) end
        if espEnabled or boxESPEnabled then
          updateESP()
        else
          for _, hl in pairs(espHighlights) do
              hl.Enabled = false
          end
          for _, box in pairs(boxESPDrawings) do
              for _, line in pairs(box) do
                  line.Visible = false
              end
          end
        end
        if configData.AntiAim ~= nil then antiAim = configData.AntiAim end
        if configData.AntiAimMethod ~= nil then antiAimMethod = configData.AntiAimMethod end
        if configData.AntiAimAmountX ~= nil then antiAimAmountX = configData.AntiAimAmountX end
        if configData.AntiAimAmountY ~= nil then antiAimAmountY = configData.AntiAimAmountY end
        if configData.AntiAimAmountZ ~= nil then antiAimAmountZ = configData.AntiAimAmountZ end
        if configData.RandomVeloRange ~= nil then randomVeloRange = configData.RandomVeloRange end
        if configData.SpinBot ~= nil then spinBot = configData.SpinBot end
        if configData.SpinBotSpeed ~= nil then spinBotSpeed = configData.SpinBotSpeed end
        
        if aimbot then aimbot:Set(aimbotEnabled) end
        if aimpart then aimpart:Set(aimParts) end
        if smoothingslider then smoothingslider:Set(math.floor((1 - smoothing) * 100)) end
        if predictionstrength then predictionstrength:Set(predictionStrength) end
        if aimbotfov then aimbotfov:Set(aimFov) end
        if wallcheck then wallcheck:Set(wallCheck) end
        if stickyaim then stickyaim:Set(stickyAimEnabled) end
        if teamchecktoggle then teamchecktoggle:Set(teamCheck) end
        if healthchecktoggle then healthchecktoggle:Set(healthCheck) end
        if minhealth then minhealth:Set(minHealth) end
        if circlecolor then circlecolor:Set(circleColor) end
        if targetedcirclecolor then targetedcirclecolor:Set(targetedCircleColor) end
        if circlerainbow then circlerainbow:Set(rainbowFov) end
        if antiaimtoggle then antiaimtoggle:Set(antiAim) end
        if antiaimmethod then antiaimmethod:Set(antiAimMethod) end
        if antiaimamountx then antiaimamountx:Set(antiAimAmountX) end
        if antiaimamounty then antiaimamounty:Set(antiAimAmountY) end
        if antiaimamountz then antiaimamountz:Set(antiAimAmountZ) end
        if randomvelorange then randomvelorange:Set(randomVeloRange) end
        if spinbottoggle then spinbottoggle:Set(spinBot) end
        if spinbotspeed then spinbotspeed:Set(spinBotSpeed) end
        
        Rayfield:Notify({
            Title = "Configuration Loaded", 
            Content = "All settings have been loaded successfully!", 
            Duration = 1, 
            Image = 4483362458,
        })
        return true
    else
        Rayfield:Notify({
            Title = "Load Failed", 
            Content = "Failed to load configuration!", 
            Duration = 2, 
            Image = 4483362458,
        })
        return false
    end
end

local function exportConfiguration()
    local configData = {
        AimbotEnabled = aimbotEnabled,
        AimParts = aimParts,
        Smoothing = smoothing,
        PredictionStrength = predictionStrength,
        AimFov = aimFov,
        WallCheck = wallCheck,
        StickyAim = stickyAimEnabled,
        TeamCheck = teamCheck,
        HealthCheck = healthCheck,
        MinHealth = minHealth,
        CircleColor = {R = circleColor.R, G = circleColor.G, B = circleColor.B},
        TargetedCircleColor = {R = targetedCircleColor.R, G = targetedCircleColor.G, B = targetedCircleColor.B},
        RainbowFov = rainbowFov,
        ESPEnabled = espEnabled,
        ESPTeamCheck = espTeamCheck,
        ESPColor = {R = espColor.R, G = espColor.G, B = espColor.B},
        BoxESPEnabled = boxESPEnabled,
        BoxESPColor = {R = boxESPColor.R, G = boxESPColor.G, B = boxESPColor.B},
        BoxESPThickness = boxESPThickness,
        AntiAim = antiAim,
        AntiAimMethod = antiAimMethod,
        AntiAimAmountX = antiAimAmountX,
        AntiAimAmountY = antiAimAmountY,
        AntiAimAmountZ = antiAimAmountZ,
        RandomVeloRange = randomVeloRange,
        SpinBot = spinBot,
        SpinBotSpeed = spinBotSpeed
    }
    
    local success, jsonData = pcall(function()
        return HttpService:JSONEncode(configData)
    end)
    
    if success then
        setclipboard(jsonData)
        Rayfield:Notify({
            Title = "Config Exported", 
            Content = "Configuration copied to clipboard!", 
            Duration = 1, 
            Image = 4483362458,
        })
    else
        Rayfield:Notify({
            Title = "Export Failed", 
            Content = "Failed to export configuration!", 
            Duration = 2, 
            Image = 4483362458,
        })
    end
end

local function importConfiguration()
    Rayfield:Prompt({
        Title = "Import Configuration",
        SubTitle = "Paste your config JSON data:",
        Actions = {
            {
                Title = "Import",
                Args = {"ConfigData"}
            },
            {
                Title = "Cancel"
            }
        }
    }):Then(function(Result)
        if Result and Result[1] == "ConfigData" then
            local success, configData = pcall(function()
                return HttpService:JSONDecode(Result[2])
            end)
            
            if success and configData then
                if configData.AimbotEnabled ~= nil then
                    aimbotEnabled = configData.AimbotEnabled
                    fovCircle.Visible = aimbotEnabled
                end
                
                if configData.AimParts ~= nil then aimParts = configData.AimParts end
                if configData.Smoothing ~= nil then smoothing = configData.Smoothing end
                if configData.PredictionStrength ~= nil then predictionStrength = configData.PredictionStrength end
                if configData.AimFov ~= nil then
                    aimFov = configData.AimFov
                    fovCircle.Radius = aimFov
                end
                if configData.WallCheck ~= nil then wallCheck = configData.WallCheck end
                if configData.StickyAim ~= nil then stickyAimEnabled = configData.StickyAim end
                if configData.TeamCheck ~= nil then teamCheck = configData.TeamCheck end
                if configData.HealthCheck ~= nil then healthCheck = configData.HealthCheck end
                if configData.MinHealth ~= nil then minHealth = configData.MinHealth end
                
                if configData.CircleColor ~= nil then
                    circleColor = Color3.new(configData.CircleColor.R, configData.CircleColor.G, configData.CircleColor.B)
                    fovCircle.Color = circleColor
                end
                
                if configData.TargetedCircleColor ~= nil then
                    targetedCircleColor = Color3.new(configData.TargetedCircleColor.R, configData.TargetedCircleColor.G, configData.TargetedCircleColor.B)
                end
                
                if configData.RainbowFov ~= nil then rainbowFov = configData.RainbowFov end
                if configData.ESPEnabled ~= nil then espEnabled = configData.ESPEnabled end
                if configData.ESPTeamCheck ~= nil then espTeamCheck = configData.ESPTeamCheck end
                if configData.ESPColor ~= nil then
                  espColor = Color3.new(configData.ESPColor.R, configData.ESPColor.G, configData.ESPColor.B)
                end
                if configData.BoxESPEnabled ~= nil then boxESPEnabled = configData.BoxESPEnabled end
                if configData.BoxESPColor ~= nil then
                  boxESPColor = Color3.new(configData.BoxESPColor.R, configData.BoxESPColor.G, configData.BoxESPColor.B)
                end
                if configData.BoxESPThickness ~= nil then boxESPThickness = configData.BoxESPThickness end
                if configData.AntiAim ~= nil then antiAim = configData.AntiAim end
                if configData.AntiAimMethod ~= nil then antiAimMethod = configData.AntiAimMethod end
                if configData.AntiAimAmountX ~= nil then antiAimAmountX = configData.AntiAimAmountX end
                if configData.AntiAimAmountY ~= nil then antiAimAmountY = configData.AntiAimAmountY end
                if configData.AntiAimAmountZ ~= nil then antiAimAmountZ = configData.AntiAimAmountZ end
                if configData.RandomVeloRange ~= nil then randomVeloRange = configData.RandomVeloRange end
                if configData.SpinBot ~= nil then spinBot = configData.SpinBot end
                if configData.SpinBotSpeed ~= nil then spinBotSpeed = configData.SpinBotSpeed end
                
                if aimbot then aimbot:Set(aimbotEnabled) end
                if aimpart then aimpart:Set(aimParts) end
                if smoothingslider then smoothingslider:Set((1 - smoothing) * 100) end
                if predictionstrength then predictionstrength:Set(predictionStrength) end
                if aimbotfov then aimbotfov:Set(aimFov) end
                if wallcheck then wallcheck:Set(wallCheck) end
                if stickyaim then stickyaim:Set(stickyAimEnabled) end
                if teamchecktoggle then teamchecktoggle:Set(teamCheck) end
                if healthchecktoggle then healthchecktoggle:Set(healthCheck) end
                if minhealth then minhealth:Set(minHealth) end
                if circlecolor then circlecolor:Set(circleColor) end
                if targetedcirclecolor then targetedcirclecolor:Set(targetedCircleColor) end
                if circlerainbow then circlerainbow:Set(rainbowFov) end
                if espToggle then espToggle:Set(espEnabled) end
                if boxESPToggle then boxESPToggle:Set(boxESPEnabled) end
                if espTeamCheckToggle then espTeamCheckToggle:Set(espTeamCheck) end
                if espColorPicker then espColorPicker:Set(espColor) end
                if boxESPColorPicker then boxESPColorPicker:Set(boxESPColor) end
                if boxESPThicknessSlider then boxESPThicknessSlider:Set(boxESPThickness) end
                if antiaimtoggle then antiaimtoggle:Set(antiAim) end
                if antiaimmethod then antiaimmethod:Set(antiAimMethod) end
                if antiaimamountx then antiaimamountx:Set(antiAimAmountX) end
                if antiaimamounty then antiaimamounty:Set(antiAimAmountY) end
                if antiaimamountz then antiaimamountz:Set(antiAimAmountZ) end
                if randomvelorange then randomvelorange:Set(randomVeloRange) end
                if spinbottoggle then spinbottoggle:Set(spinBot) end
                if spinbotspeed then spinbotspeed:Set(spinBotSpeed) end

                if espEnabled or boxESPEnabled then
                    updateESP()
                else
                    for _, hl in pairs(espHighlights) do
                        hl.Enabled = false
                    end
                    for _, box in pairs(boxESPDrawings) do
                        for _, line in pairs(box) do
                            line.Visible = false
                        end
                    end
                end
                
                Rayfield:Notify({
                    Title = "Config Imported", 
                    Content = "Configuration imported successfully!", 
                    Duration = 1, 
                    Image = 4483362458,
                })
            else
                Rayfield:Notify({
                    Title = "Import Failed", 
                    Content = "Invalid config data format!", 
                    Duration = 2, 
                    Image = 4483362458,
                })
            end
        end
    end)
end

Misc:CreateButton({
    Name = "üíæ Save Current Config",
    Callback = saveConfiguration
})

Misc:CreateButton({
    Name = "üìÇ Load Saved Config", 
    Callback = loadConfiguration
})

Misc:CreateButton({
    Name = "üì§ Export Config to Clipboard",
    Callback = exportConfiguration
})

Misc:CreateButton({
    Name = "üì• Import Config from Clipboard",
    Callback = importConfiguration
})

spawn(function()
    wait(2)
    if isfile(configFileName) then
        loadConfiguration()
    end
end)

local function cleanup()
    if fovCircle then fovCircle:Remove() end
    for _, hl in pairs(espHighlights) do
        hl:Destroy()
    end
    espHighlights = {}
    
    for _, box in pairs(boxESPDrawings) do
        for _, line in pairs(box) do
            line:Remove()
        end
    end
    boxESPDrawings = {}
end

plr:GetPropertyChangedSignal("Parent"):Connect(function()
    if not plr.Parent then
        cleanup()
    end
end)
