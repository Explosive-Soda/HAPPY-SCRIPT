-- Source Code ESP
local SourceCode = {
    Enabled = true,
    Boxes = false,
    BoxShift = CFrame.new(0,-1.5,0),
	BoxSize = Vector3.new(4,6,0),
    Color = Color3.fromRGB(255, 255, 255),
    FaceCamera = false,
    Names = true,
    TeamColor = false,
    Thickness = 2,
    AttachShift = 1,
    TeamMates = true,
    Players = false,
    Tracers = false,
    
    Objects = setmetatable({}, {__mode="kv"}),
    Overrides = {}
}

-- 颜色配置
local CurrentColor = Color3.fromRGB(255, 255, 255)

-- 创建GUI
local gui = Instance.new("ScreenGui", game.CoreGui)
gui.Name = "SourceCodeESP"
gui.ResetOnSpawn = false

local frame = Instance.new("Frame", gui)
frame.Position = UDim2.new(0.5, -100, 0.5, -75)
frame.Size = UDim2.new(0, 200, 0, 100)
frame.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
frame.BorderColor3 = Color3.fromRGB(255, 255, 255)
frame.Visible = false

local function makeLabel(name, y)
	local label = Instance.new("TextLabel", frame)
	label.Text = name
	label.TextColor3 = Color3.new(1, 1, 1)
	label.BackgroundTransparency = 1
	label.Position = UDim2.new(0, 10, 0, y)
	label.Size = UDim2.new(0, 80, 0, 20)
	label.Font = Enum.Font.SourceSans
	label.TextSize = 14
	label.TextXAlignment = Enum.TextXAlignment.Left
	return label
end

-- RGB 颜色输入框
local function makeRGB(y)
	local boxes = {}
	for i, colorName in ipairs({"R", "G", "B"}) do
		local box = Instance.new("TextBox", frame)
		box.Position = UDim2.new(0, 90 + (i - 1) * 30, 0, y)
		box.Size = UDim2.new(0, 28, 0, 20)
		box.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		box.BorderColor3 = Color3.new(1, 1, 1)
		box.Text = "255"
		box.Font = Enum.Font.SourceSans
		box.TextSize = 14
		box.TextColor3 = Color3.new(0, 0, 0)
		box.ClearTextOnFocus = true
		box.FocusLost:Connect(function()
			local r = tonumber(boxes[1].Text) or 255
			local g = tonumber(boxes[2].Text) or 255
			local b = tonumber(boxes[3].Text) or 255
			
			-- 确保数值在有效范围内
			r = math.clamp(r, 0, 255)
			g = math.clamp(g, 0, 255)
			b = math.clamp(b, 0, 255)
			
			CurrentColor = Color3.fromRGB(r, g, b)
			SourceCode.Color = CurrentColor
			
			-- 更新所有现有对象的颜色
			for obj, espBox in pairs(SourceCode.Objects) do
				if espBox.Components then
					for _, component in pairs(espBox.Components) do
						component.Color = CurrentColor
					end
				end
			end
			
			print("颜色已更改为: RGB(" .. r .. "," .. g .. "," .. b .. ")")
		end)
		table.insert(boxes, box)
	end
end

-- 创建组件
makeLabel("COLOUR", 10)
makeRGB(10)

makeLabel("右侧Alt显示GUI", 40)
makeLabel("右侧Ctrl开关ESP", 60)

-- GUI 拖动功能
local dragging = false
local dragStart = nil
local startPos = nil

frame.InputBegan:Connect(function(input, gp)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		startPos = frame.Position
	end
end)

frame.InputChanged:Connect(function(input)
	if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = input.Position - dragStart
		frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
end)

frame.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = false
	end
end)

-- GUI 显隐控制（右侧Alt键）
local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(function(input, gp)
	if not gp and input.KeyCode == Enum.KeyCode.RightAlt then
		frame.Visible = not frame.Visible
	end
end)

-- ESP 开关控制（右侧Ctrl键）
UserInputService.InputBegan:Connect(function(input, gameProcessed)
	if not gameProcessed and input.KeyCode == Enum.KeyCode.RightControl then
		SourceCode.Enabled = not SourceCode.Enabled
		SourceCode:Toggle(SourceCode.Enabled)
		print("ESP 状态:", SourceCode.Enabled and "启用" or "禁用")
	end
end)

local cam = workspace.CurrentCamera
local plrs = game:GetService("Players")
local plr = plrs.LocalPlayer

local V3new = Vector3.new
local WorldToViewportPoint = cam.WorldToViewportPoint

local function Draw(obj, props)
	local new = Drawing.new(obj)
	props = props or {}
	for i,v in pairs(props) do
		new[i] = v
	end
	return new
end

function SourceCode:GetTeam(p)
	local ov = self.Overrides.GetTeam
	if ov then
		return ov(p)
	end
	return p and p.Team
end

function SourceCode:IsTeamMate(p)
    local ov = self.Overrides.IsTeamMate
	if ov then
		return ov(p)
    end
    return self:GetTeam(p) == self:GetTeam(plr)
end

function SourceCode:GetColor(obj)
	local ov = self.Overrides.GetColor
	if ov then
		return ov(obj)
    end
    local p = self:GetPlrFromChar(obj)
	return p and self.TeamColor and p.Team and p.Team.TeamColor.Color or self.Color
end

function SourceCode:GetPlrFromChar(char)
	local ov = self.Overrides.GetPlrFromChar
	if ov then
		return ov(char)
	end
	return plrs:GetPlayerFromCharacter(char)
end

function SourceCode:Toggle(bool)
    self.Enabled = bool
    if not bool then
        for i,v in pairs(self.Objects) do
            if v.Type == "Box" then
                if v.Temporary then
                    v:Remove()
                else
                    for i,v in pairs(v.Components) do
                        v.Visible = false
                    end
                end
            end
        end
    else
        for i,v in pairs(self.Objects) do
            if v.Type == "Box" then
                for i,component in pairs(v.Components) do
                    component.Visible = true
                end
            end
        end
    end
end

function SourceCode:GetBox(obj)
    return self.Objects[obj]
end

function SourceCode:AddObjectListener(parent, options)
    local function NewListener(c)
        if type(options.Type) == "string" and c:IsA(options.Type) or options.Type == nil then
            if type(options.Name) == "string" and c.Name == options.Name or options.Name == nil then
                if not options.Validator or options.Validator(c) then
                    local box = SourceCode:Add(c, {
                        PrimaryPart = type(options.PrimaryPart) == "string" and c:WaitForChild(options.PrimaryPart) or type(options.PrimaryPart) == "function" and options.PrimaryPart(c),
                        Color = type(options.Color) == "function" and options.Color(c) or options.Color or CurrentColor,
                        ColorDynamic = options.ColorDynamic,
                        Name = type(options.CustomName) == "function" and options.CustomName(c) or options.CustomName,
                        IsEnabled = options.IsEnabled,
                        RenderInNil = options.RenderInNil
                    })
                    if options.OnAdded then
                        coroutine.wrap(options.OnAdded)(box)
                    end
                end
            end
        end
    end

    if options.Recursive then
        parent.DescendantAdded:Connect(NewListener)
        for i,v in pairs(parent:GetDescendants()) do
            coroutine.wrap(NewListener)(v)
        end
    else
        parent.ChildAdded:Connect(NewListener)
        for i,v in pairs(parent:GetChildren()) do
            coroutine.wrap(NewListener)(v)
        end
    end
end

local boxBase = {}
boxBase.__index = boxBase

function boxBase:Remove()
    SourceCode.Objects[self.Object] = nil
    for i,v in pairs(self.Components) do
        v.Visible = false
        v:Remove()
        self.Components[i] = nil
    end
end

function boxBase:Update()
    if not self.PrimaryPart then
        return self:Remove()
    end

    local color = self.Color or self.ColorDynamic and self:ColorDynamic() or SourceCode:GetColor(self.Object) or CurrentColor

    local allow = true
    if SourceCode.Overrides.UpdateAllow and not SourceCode.Overrides.UpdateAllow(self) then
        allow = false
    end
    if self.Player and not SourceCode.TeamMates and SourceCode:IsTeamMate(self.Player) then
        allow = false
    end
    if self.Player and not SourceCode.Players then
        allow = false
    end
    if self.IsEnabled and (type(self.IsEnabled) == "string" and not SourceCode[self.IsEnabled] or type(self.IsEnabled) == "function" and not self:IsEnabled()) then
        allow = false
    end
    if not workspace:IsAncestorOf(self.PrimaryPart) and not self.RenderInNil then
        allow = false
    end

    if not allow then
        for i,v in pairs(self.Components) do
            v.Visible = false
        end
        return
    end

    local cf = self.PrimaryPart.CFrame
    if SourceCode.FaceCamera then
        cf = CFrame.new(cf.p, cam.CFrame.p)
    end
    local size = self.Size
    local locs = {
        TopLeft = cf * SourceCode.BoxShift * CFrame.new(size.X/2,size.Y/2,0),
        TopRight = cf * SourceCode.BoxShift * CFrame.new(-size.X/2,size.Y/2,0),
        BottomLeft = cf * SourceCode.BoxShift * CFrame.new(size.X/2,-size.Y/2,0),
        BottomRight = cf * SourceCode.BoxShift * CFrame.new(-size.X/2,-size.Y/2,0),
        TagPos = cf * SourceCode.BoxShift * CFrame.new(0,size.Y/2,0),
        Torso = cf * SourceCode.BoxShift
    }

    if SourceCode.Names then
        local TagPos, Vis5 = WorldToViewportPoint(cam, locs.TagPos.p)
        
        if Vis5 then
            self.Components.Name.Visible = true
            self.Components.Name.Position = Vector2.new(TagPos.X, TagPos.Y)
            self.Components.Name.Text = self.Name
            self.Components.Name.Color = color
            
            self.Components.Distance.Visible = true
            self.Components.Distance.Position = Vector2.new(TagPos.X, TagPos.Y + 14)
            self.Components.Distance.Text = math.floor((cam.CFrame.p - cf.p).magnitude) .."m away"
            self.Components.Distance.Color = color
        else
            self.Components.Name.Visible = false
            self.Components.Distance.Visible = false
        end
    else
        self.Components.Name.Visible = false
        self.Components.Distance.Visible = false
    end
end

function SourceCode:Add(obj, options)
    if not obj.Parent and not options.RenderInNil then
        return warn(obj, "has no parent")
    end

    local box = setmetatable({
        Name = options.Name or obj.Name,
        Type = "Box",
        Color = options.Color or CurrentColor,
        Size = options.Size or self.BoxSize,
        Object = obj,
        Player = options.Player or plrs:GetPlayerFromCharacter(obj),
        PrimaryPart = options.PrimaryPart or obj.ClassName == "Model" and (obj.PrimaryPart or obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChildWhichIsA("BasePart")) or obj:IsA("BasePart") and obj,
        Components = {},
        IsEnabled = options.IsEnabled,
        Temporary = options.Temporary,
        ColorDynamic = options.ColorDynamic,
        RenderInNil = options.RenderInNil
    }, boxBase)

    if self:GetBox(obj) then
        self:GetBox(obj):Remove()
    end

    box.Components["Name"] = Draw("Text", {
		Text = box.Name,
		Color = box.Color,
		Center = true,
		Outline = true,
        Size = 19,
        Visible = self.Enabled and self.Names
	})
	box.Components["Distance"] = Draw("Text", {
		Color = box.Color,
		Center = true,
		Outline = true,
        Size = 19,
        Visible = self.Enabled and self.Names
	})
    
    self.Objects[obj] = box
    
    obj.AncestryChanged:Connect(function(_, parent)
        if parent == nil and SourceCode.AutoRemove ~= false then
            box:Remove()
        end
    end)
    obj:GetPropertyChangedSignal("Parent"):Connect(function()
        if obj.Parent == nil and SourceCode.AutoRemove ~= false then
            box:Remove()
        end
    end)

    return box
end

-- 主循环
game:GetService("RunService").RenderStepped:Connect(function()
    cam = workspace.CurrentCamera
    for i,v in (SourceCode.Enabled and pairs or ipairs)(SourceCode.Objects) do
        if v.Update then
            local s,e = pcall(v.Update, v)
            if not s then warn("[EU]", e, v.Object:GetFullName()) end
        end
    end
end)

-- 初始启用
SourceCode:Toggle(true)

return SourceCode
